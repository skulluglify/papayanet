package basic

import (
  "crypto/rand"
  "encoding/base64"
  "errors"
  "github.com/golang-jwt/jwt/v5"
  "time"
)

// generated by chatGPT, yeah or right, is so powerful.
// but need little fix for work well

// CreateSecretKey generates a new random secret key
func CreateSecretKey() (string, error) {

  key := make([]byte, 32)

  _, err := rand.Read(key)

  if err != nil {

    return "", err
  }

  return base64.URLEncoding.EncodeToString(key), nil
}

// EncodeJWT encodes a map of claims into a JWT token string
func EncodeJWT(data map[string]any, secret string) (string, error) {

  claims := jwt.MapClaims(data)

  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

  return token.SignedString([]byte(secret))
}

// DecodeJWT decodes a JWT token string and returns the claims if successful
func DecodeJWT(token string, secret string) (jwt.MapClaims, bool, error) {

  claims := jwt.MapClaims{}

  parsedToken, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {
    return []byte(secret), nil
  })

  if err != nil {

    if err == jwt.ErrSignatureInvalid {
      return nil, false, errors.New("invalid token signature")
    }

    return nil, false, err
  }

  if !parsedToken.Valid {
    return nil, false, errors.New("invalid token")
  }

  return claims, true, nil
}

// ExpiredJWT checks if a JWT token string is expired
func ExpiredJWT(token string, expirationTime time.Time) bool {

  claims := jwt.MapClaims{}

  _, _ = jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {

    return []byte{}, nil
  })

  if exp, ok := claims["exp"].(float64); ok {

    return time.Unix(int64(exp), 0).Before(expirationTime)
  }

  return true
}
